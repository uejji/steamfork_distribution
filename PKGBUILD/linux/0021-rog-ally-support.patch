diff -rupN linux-6.10.7.orig/drivers/platform/x86/asus-wmi.c linux-6.10.7/drivers/platform/x86/asus-wmi.c
--- linux-6.10.7.orig/drivers/platform/x86/asus-wmi.c	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/drivers/platform/x86/asus-wmi.c	2024-09-01 15:27:11.932453279 +0000
@@ -11,8 +11,11 @@
  * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
  */
 
+#include "linux/usb/ch9.h"
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include "linux/printk.h"
+
 #include <linux/acpi.h>
 #include <linux/backlight.h>
 #include <linux/debugfs.h>
@@ -137,10 +140,9 @@ module_param(fnlock_default, bool, 0444)
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
-/* Controls the power state of the USB0 hub on ROG Ally which input is on */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/* 300ms so far seems to produce a reliable result on AC and battery */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
+/* The period required to wait after screen off/on/s2idle.check in MS */
+#define ASUS_USB0_PWR_EC0_CSEE_WAIT 300
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
@@ -254,9 +256,6 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
-	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
-	bool ally_mcu_usb_switch;
-
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -315,6 +314,9 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
+static bool ally_mcu_usb_switch;
+static int ally_suspended_power_state;
+
 /* WMI ************************************************************************/
 
 static int asus_wmi_evaluate_method3(u32 method_id,
@@ -1685,7 +1687,8 @@ static int asus_wmi_led_init(struct asus
 			goto error;
 	}
 
-	if (!kbd_led_read(asus, &led_val, NULL)) {
+	if (!kbd_led_read(asus, &led_val, NULL) && !dmi_match(DMI_BOARD_NAME, "RC71L")) {
+		pr_info("using asus-wmi for asus::kbd_backlight\n");
 		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
 		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
@@ -4344,6 +4347,20 @@ static struct attribute *platform_attrib
 	NULL
 };
 
+bool asus_ally_has_quirk(unsigned long quirk)
+{
+	const struct dmi_system_id *dmi_id;
+	unsigned long quirks;
+
+	dmi_id = dmi_first_match(asus_ally_mcu_quirk);
+	if (!dmi_id)
+		return false;
+
+	quirks = (unsigned long)dmi_id->driver_data;
+	return quirks & quirk;
+}
+EXPORT_SYMBOL_GPL(asus_ally_has_quirk);
+
 static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr, int idx)
 {
@@ -4390,7 +4407,9 @@ static umode_t asus_sysfs_is_visible(str
 		devid = ASUS_WMI_DEVID_NV_DYN_BOOST;
 	else if (attr == &dev_attr_nv_temp_target.attr)
 		devid = ASUS_WMI_DEVID_NV_THERM_TARGET;
-	else if (attr == &dev_attr_mcu_powersave.attr)
+	else if (attr == &dev_attr_mcu_powersave.attr &&
+			!asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE))
+		/* Show only for Ally X +, as Ally 1 needs it forced off */
 		devid = ASUS_WMI_DEVID_MCU_POWERSAVE;
 	else if (attr == &dev_attr_boot_sound.attr)
 		devid = ASUS_WMI_DEVID_BOOT_SOUND;
@@ -4637,6 +4656,22 @@ static int asus_wmi_add(struct platform_
 	if (err)
 		goto fail_platform;
 
+	ally_mcu_usb_switch = dmi_check_system(asus_ally_mcu_quirk);
+	if (ally_mcu_usb_switch) {
+		/*
+		 * These steps ensure the device is in a valid good state, this is
+		 * especially important for the Ally 1 after a reboot.
+		 */
+		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8);
+		msleep(500);
+		platform_suspend_screen_on();
+	}
+	if (asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_MCU_POWERSAVE, 0, &result);
+		if (err)
+			pr_warn("Failed to force MCU powersave off for RC71L: %d\n", err);
+	}
+
 	/* ensure defaults for tunables */
 	asus->ppt_pl2_sppt = 5;
 	asus->ppt_pl1_spl = 5;
@@ -4649,8 +4684,6 @@ static int asus_wmi_add(struct platform_
 	asus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
-	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-						&& dmi_match(DMI_BOARD_NAME, "RC71L");
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -4843,34 +4876,6 @@ static int asus_hotk_resume(struct devic
 	return 0;
 }
 
-static int asus_hotk_resume_early(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
-			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-static int asus_hotk_prepare(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to ensure USB0 is disabled before sleep continues */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
-			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -4911,11 +4916,81 @@ static int asus_hotk_restore(struct devi
 	return 0;
 }
 
+static void asus_ally_s2idle_check(void)
+{
+	int power_state;
+
+	if (ally_mcu_usb_switch) {
+		int powersave = 0;
+		power_state = power_supply_is_system_supplied();
+		/* Wake the device fully if AC plugged in. Prevents many issues */
+		if (power_state > 0 &&
+		    ally_suspended_power_state != power_state &&
+		    !asus_ally_has_quirk(ASUS_ROG_ALLY_NO_WAKE)) {
+			pm_system_wakeup();
+			return;
+		}
+
+		/*
+		 * Required to ensure device is in good state on proper resume. The device
+		 * does a partial wake on AC unplug and this can leave an Ally X in bad state.
+		 */
+		if (!asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+			if (powersave && ally_suspended_power_state != power_state) {
+				acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7);
+				msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+			}
+		}
+	}
+}
+
+static void asus_ally_s2idle_restore(void)
+{
+	if (ally_mcu_usb_switch) {
+		int powersave = 0;
+		/* Ally X powersave-on requires this */
+		if (!asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+			asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+			if (powersave)
+				acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8);
+		}
+
+		platform_suspend_screen_on();
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+}
+
+static int asus_hotk_prepare(struct device *device)
+{
+	if (ally_mcu_usb_switch) {
+		int powersave = 0;
+		/* Ally X powersave-on requires this */
+		if (!asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+			asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+			if (powersave)
+				acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7);
+		}
+
+		ally_suspended_power_state = power_supply_is_system_supplied();
+		platform_suspend_screen_off();
+		/*
+		 * Time here greatly impacts the wake behaviour
+		 * Too little and device never appears, too much and disconnect events occur
+		 */
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
+static struct acpi_s2idle_dev_ops asus_ally_s2idle_dev_ops = {
+	.check = asus_ally_s2idle_check,
+	.restore = asus_ally_s2idle_restore,
+};
+
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.resume_early = asus_hotk_resume_early,
 	.prepare = asus_hotk_prepare,
 };
 
@@ -4925,7 +5000,7 @@ static int asus_wmi_probe(struct platfor
 {
 	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
 	struct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);
-	int ret;
+	int ret, err;
 
 	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
 		pr_warn("ASUS Management GUID not found\n");
@@ -4943,6 +5018,10 @@ static int asus_wmi_probe(struct platfor
 			return ret;
 	}
 
+	err = acpi_register_lps0_dev(&asus_ally_s2idle_dev_ops);
+	if (err)
+		pr_warn("failed to register LPS0 sleep handler in asus-wmi\n");
+
 	return asus_wmi_add(pdev);
 }
 
@@ -4975,6 +5054,7 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driv
 
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
+	acpi_unregister_lps0_dev(&asus_ally_s2idle_dev_ops);
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
 	used = false;
diff -rupN linux-6.10.7.orig/drivers/platform/x86/asus-wmi.h linux-6.10.7/drivers/platform/x86/asus-wmi.h
--- linux-6.10.7.orig/drivers/platform/x86/asus-wmi.h	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/drivers/platform/x86/asus-wmi.h	2024-09-01 02:55:40.578822949 +0000
@@ -16,6 +16,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/i8042.h>
+#include <linux/dmi.h>
 
 #define ASUS_WMI_KEY_IGNORE (-1)
 #define ASUS_WMI_BRN_DOWN	0x2e
@@ -85,4 +86,25 @@ struct asus_wmi_driver {
 int asus_wmi_register_driver(struct asus_wmi_driver *driver);
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver);
 
+#define ASUS_ROG_ALLY_NO_POWERSAVE	BIT(0)
+#define ASUS_ROG_ALLY_NO_WAKE		BIT(1)
+
+/* To be used by both asus-armoury and asus-wmi */
+static const struct dmi_system_id asus_ally_mcu_quirk[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+		.driver_data = (void *)(ASUS_ROG_ALLY_NO_POWERSAVE | ASUS_ROG_ALLY_NO_WAKE),
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
+		},
+	},
+	{ },
+};
+
+bool asus_ally_has_quirk(unsigned long quirk);
+
 #endif /* !_ASUS_WMI_H_ */
diff -rupN linux-6.10.6.orig/drivers/hid/hid-asus.c linux-6.10.6/drivers/hid/hid-asus.c
--- linux-6.10.6.orig/drivers/hid/hid-asus.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/hid/hid-asus.c	2024-08-24 04:13:17.225649121 +0000
@@ -52,6 +52,10 @@ MODULE_DESCRIPTION("Asus HID Keyboard an
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
+#define ALLY_CFG_INTF_IN_ADDRESS 0x83
+#define ALLY_CFG_INTF_OUT_ADDRESS 0x04
+#define ALLY_X_INTERFACE_ADDRESS 0x87
+
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
 #define MAX_TOUCH_MAJOR 8
@@ -84,6 +88,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard an
 #define QUIRK_MEDION_E1239T		BIT(10)
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
+#define QUIRK_ROG_ALLY_XPAD		BIT(13)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -492,12 +497,19 @@ static void asus_kbd_backlight_work(stru
  */
 static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
 {
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
 	u32 value;
 	int ret;
 
 	if (!IS_ENABLED(CONFIG_ASUS_WMI))
 		return false;
 
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
+			dmi_match(DMI_BOARD_NAME, "RC71L")) {
+		hid_info(hdev, "using HID for asus::kbd_backlight\n");
+		return false;
+	}
+
 	ret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,
 				       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);
 	hid_dbg(hdev, "WMI backlight check: rc %d value %x", ret, value);
@@ -996,6 +1008,17 @@ static int asus_probe(struct hid_device
 
 	drvdata->quirks = id->driver_data;
 
+	/* Ignore these endpoints as they will be used by other drivers */
+	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+		struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+		struct usb_host_endpoint *ep = intf->cur_altsetting->endpoint;
+
+		if (ep->desc.bEndpointAddress == ALLY_X_INTERFACE_ADDRESS ||
+			ep->desc.bEndpointAddress == ALLY_CFG_INTF_IN_ADDRESS ||
+			ep->desc.bEndpointAddress == ALLY_CFG_INTF_OUT_ADDRESS)
+			return -ENODEV;
+	}
+
 	/*
 	 * T90CHI's keyboard dock returns same ID values as T100CHI's dock.
 	 * Thus, identify T90CHI dock with product name string.
@@ -1247,7 +1270,10 @@ static const struct hid_device_id asus_d
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
+	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
diff -rupN linux-6.10.6.orig/drivers/hid/hid-ids.h linux-6.10.6/drivers/hid/hid-ids.h
--- linux-6.10.6.orig/drivers/hid/hid-ids.h	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/hid/hid-ids.h	2024-08-25 03:25:38.369296369 +0000
@@ -210,6 +210,7 @@
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD3	0x1a30
 #define USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR		0x18c6
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY		0x1abe
+#define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X		0x1b4c
 #define USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD	0x196b
 #define USB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD	0x1869
 
diff -rupN linux-6.10.7.orig/sound/pci/hda/patch_realtek.c linux-6.10.7/sound/pci/hda/patch_realtek.c
--- linux-6.10.7.orig/sound/pci/hda/patch_realtek.c	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/sound/pci/hda/patch_realtek.c	2024-08-31 01:24:15.754474754 +0000
@@ -7408,6 +7408,7 @@ enum {
 	ALC285_FIXUP_THINKPAD_X1_GEN7,
 	ALC285_FIXUP_THINKPAD_HEADSET_JACK,
 	ALC294_FIXUP_ASUS_ALLY,
+	ALC294_FIXUP_ASUS_ALLY_X,
 	ALC294_FIXUP_ASUS_ALLY_PINS,
 	ALC294_FIXUP_ASUS_ALLY_VERBS,
 	ALC294_FIXUP_ASUS_ALLY_SPEAKER,
@@ -8874,6 +8875,12 @@ static const struct hda_fixup alc269_fix
 		.chained = true,
 		.chain_id = ALC294_FIXUP_ASUS_ALLY_PINS
 	},
+	[ALC294_FIXUP_ASUS_ALLY_X] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = tas2781_fixup_i2c,
+		.chained = true,
+		.chain_id = ALC294_FIXUP_ASUS_ALLY_PINS
+	},
 	[ALC294_FIXUP_ASUS_ALLY_PINS] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -10306,6 +10313,7 @@ static const struct snd_pci_quirk alc269
 	SND_PCI_QUIRK(0x1043, 0x1740, "ASUS UX430UA", ALC295_FIXUP_ASUS_DACS),
 	SND_PCI_QUIRK(0x1043, 0x17d1, "ASUS UX431FL", ALC294_FIXUP_ASUS_DUAL_SPK),
 	SND_PCI_QUIRK(0x1043, 0x17f3, "ROG Ally NR2301L/X", ALC294_FIXUP_ASUS_ALLY),
+	SND_PCI_QUIRK(0x1043, 0x1eb3, "ROG Ally X RC72LA", ALC294_FIXUP_ASUS_ALLY_X),
 	SND_PCI_QUIRK(0x1043, 0x1863, "ASUS UX6404VI/VV", ALC245_FIXUP_CS35L41_SPI_2),
 	SND_PCI_QUIRK(0x1043, 0x1881, "ASUS Zephyrus S/M", ALC294_FIXUP_ASUS_GX502_PINS),
 	SND_PCI_QUIRK(0x1043, 0x18b1, "Asus MJ401TA", ALC256_FIXUP_ASUS_HEADSET_MIC),
diff -rupN linux-6.10.6.orig/drivers/platform/x86/amd/pmf/pmf-quirks.c linux-6.10.6/drivers/platform/x86/amd/pmf/pmf-quirks.c
--- linux-6.10.6.orig/drivers/platform/x86/amd/pmf/pmf-quirks.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/platform/x86/amd/pmf/pmf-quirks.c	2024-08-24 11:58:42.128829894 +0000
@@ -29,6 +29,14 @@ static const struct dmi_system_id fwbug_
 		},
 		.driver_data = &quirk_no_sps_bug,
 	},
+	{
+		.ident = "ROG Ally X",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "RC72LA"),
+		},
+		.driver_data = &quirk_no_sps_bug,
+	},
 	{}
 };
 
