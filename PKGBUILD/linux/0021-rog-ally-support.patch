diff -rupN linux-6.10.7.orig/drivers/platform/x86/asus-wmi.c linux-6.10.7/drivers/platform/x86/asus-wmi.c
--- linux-6.10.7.orig/drivers/platform/x86/asus-wmi.c	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/drivers/platform/x86/asus-wmi.c	2024-09-03 15:16:17.351808373 +0000
@@ -137,10 +137,11 @@ module_param(fnlock_default, bool, 0444)
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
-/* Controls the power state of the USB0 hub on ROG Ally which input is on */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/* 300ms so far seems to produce a reliable result on AC and battery */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
+/* The period required to wait after screen off/on/s2idle.check in MS */
+#define ASUS_USB0_PWR_EC0_CSEE_WAIT	200
+#define ASUS_USB0_PWR_EC0_CSEE_ON	0xB8
+#define ASUS_USB0_PWR_EC0_CSEE_OFF	0xB7
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
@@ -254,9 +255,6 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
-	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
-	bool ally_mcu_usb_switch;
-
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -315,6 +313,8 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
+static bool ally_mcu_usb_switch;
+
 /* WMI ************************************************************************/
 
 static int asus_wmi_evaluate_method3(u32 method_id,
@@ -503,6 +503,23 @@ static int asus_wmi_get_devstate(struct
 	return 0;
 }
 
+/* For use with devices where the ACPI get method is always ASUS_WMI_METHODID_DSTS */
+static int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval)
+{
+	int err;
+
+	err = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, dev_id, 0, retval);
+	*retval &= ~ASUS_WMI_DSTS_PRESENCE_BIT;
+
+	if (err)
+		return err;
+	/* Be explicit about retval */
+	if (*retval == ASUS_WMI_UNSUPPORTED_METHOD)
+		return -ENODEV;
+
+	return 0;
+}
+
 static int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 				 u32 *retval)
 {
@@ -1685,7 +1702,8 @@ static int asus_wmi_led_init(struct asus
 			goto error;
 	}
 
-	if (!kbd_led_read(asus, &led_val, NULL)) {
+	if (!kbd_led_read(asus, &led_val, NULL) && !dmi_check_system(asus_use_hid_led_dmi_ids)) {
+		pr_info("using asus-wmi for asus::kbd_backlight\n");
 		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
 		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
@@ -4344,6 +4362,20 @@ static struct attribute *platform_attrib
 	NULL
 };
 
+bool asus_ally_has_quirk(unsigned long quirk)
+{
+	const struct dmi_system_id *dmi_id;
+	unsigned long quirks;
+
+	dmi_id = dmi_first_match(asus_ally_mcu_quirk);
+	if (!dmi_id)
+		return false;
+
+	quirks = (unsigned long)dmi_id->driver_data;
+	return quirks & quirk;
+}
+EXPORT_SYMBOL_GPL(asus_ally_has_quirk);
+
 static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr, int idx)
 {
@@ -4401,6 +4433,11 @@ static umode_t asus_sysfs_is_visible(str
 	else if (attr == &dev_attr_available_mini_led_mode.attr)
 		ok = asus->mini_led_dev_id != 0;
 
+	/* Show only for Ally X +, as Ally 1 needs it forced off */
+	if (attr == &dev_attr_mcu_powersave.attr &&
+			asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE))
+		return 0;
+
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
 
@@ -4637,6 +4674,23 @@ static int asus_wmi_add(struct platform_
 	if (err)
 		goto fail_platform;
 
+	ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
+				&& dmi_check_system(asus_ally_mcu_quirk);
+	if (ally_mcu_usb_switch) {
+		/*
+		 * These steps ensure the device is in a valid good state, this is
+		 * especially important for the Ally 1 after a reboot.
+		 */
+		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, ASUS_USB0_PWR_EC0_CSEE_ON);
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+		platform_suspend_screen_on();
+	}
+	if (asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_MCU_POWERSAVE, 0, &result);
+		if (err)
+			pr_warn("Failed to force MCU powersave off for RC71L: %d\n", err);
+	}
+
 	/* ensure defaults for tunables */
 	asus->ppt_pl2_sppt = 5;
 	asus->ppt_pl1_spl = 5;
@@ -4649,8 +4703,8 @@ static int asus_wmi_add(struct platform_
 	asus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
-	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-						&& dmi_match(DMI_BOARD_NAME, "RC71L");
+	ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
+						&& dmi_check_system(asus_ally_mcu_quirk);
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -4843,34 +4897,6 @@ static int asus_hotk_resume(struct devic
 	return 0;
 }
 
-static int asus_hotk_resume_early(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
-			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-static int asus_hotk_prepare(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to ensure USB0 is disabled before sleep continues */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
-			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -4911,11 +4937,76 @@ static int asus_hotk_restore(struct devi
 	return 0;
 }
 
+static bool asus_ally_check_powersave(void)
+{
+	u32 powersave = 0;
+	int err;
+
+	/* Ally X requires this if powersave is enabled */
+	if (!asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+		err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+		if (err)
+			pr_err("Failed to read mcu_powersave. %d\n", err);
+		return powersave == 1;
+	}
+
+	return false;
+}
+
+static void asus_ally_s2idle_restore(void)
+{
+	if (ally_mcu_usb_switch) {
+		/* The Ally X requires this if in powersave mode or devices fail to init */
+		if (asus_ally_check_powersave())
+			if (ACPI_FAILURE(acpi_execute_simple_method(NULL,
+					ASUS_USB0_PWR_EC0_CSEE, ASUS_USB0_PWR_EC0_CSEE_ON)))
+				pr_err("ROG Ally MCU failed to restore\n");
+
+		platform_suspend_screen_on();
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+}
+
+static int asus_hotk_prepare(struct device *device)
+{
+	if (ally_mcu_usb_switch) {
+		/* The Ally X requires this if in powersave mode or devices fail to init */
+		if (asus_ally_check_powersave())
+			if (ACPI_FAILURE(acpi_execute_simple_method(NULL,
+					ASUS_USB0_PWR_EC0_CSEE,	ASUS_USB0_PWR_EC0_CSEE_OFF)))
+				pr_err("ROG Ally MCU failed to suspend\n");
+
+		platform_suspend_screen_off();
+		/*
+		 * Time here greatly impacts the wake behaviour
+		 * Too little and device never appears, too much and disconnect events occur
+		 */
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
+/*
+ * Ally X requires waking on AC-change if powersave is enabled.
+ * To prevent confusion of different behaviour, apply for all Ally
+ * regardless of quirks.
+ */
+static bool asus_ally_enable_wake(void)
+{
+	return dmi_first_match(asus_ally_mcu_quirk) != NULL;
+}
+
+/* Use only for Ally devices due to the wake_on_ac */
+static struct acpi_s2idle_dev_ops asus_ally_s2idle_dev_ops = {
+	.restore = asus_ally_s2idle_restore,
+	/* Requirement for at least Ally X to prevent powersave issues */
+	.enable_wake_on_ac_plug = asus_ally_enable_wake,
+};
+
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.resume_early = asus_hotk_resume_early,
 	.prepare = asus_hotk_prepare,
 };
 
@@ -4943,6 +5034,10 @@ static int asus_wmi_probe(struct platfor
 			return ret;
 	}
 
+	ret = acpi_register_lps0_dev(&asus_ally_s2idle_dev_ops);
+	if (ret)
+		pr_warn("failed to register LPS0 sleep handler in asus-wmi\n");
+
 	return asus_wmi_add(pdev);
 }
 
@@ -4975,6 +5070,7 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driv
 
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
+	acpi_unregister_lps0_dev(&asus_ally_s2idle_dev_ops);
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
 	used = false;
diff -rupN linux-6.10.7.orig/drivers/platform/x86/asus-wmi.h linux-6.10.7/drivers/platform/x86/asus-wmi.h
--- linux-6.10.7.orig/drivers/platform/x86/asus-wmi.h	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/drivers/platform/x86/asus-wmi.h	2024-09-03 15:03:04.542385902 +0000
@@ -16,6 +16,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/i8042.h>
+#include <linux/dmi.h>
 
 #define ASUS_WMI_KEY_IGNORE (-1)
 #define ASUS_WMI_BRN_DOWN	0x2e
@@ -85,4 +86,19 @@ struct asus_wmi_driver {
 int asus_wmi_register_driver(struct asus_wmi_driver *driver);
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver);
 
+#define ASUS_ROG_ALLY_NO_POWERSAVE	BIT(0)
+
+/* To be used by both asus-armoury and asus-wmi */
+static const struct dmi_system_id asus_ally_mcu_quirk[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+		.driver_data = (void *)(ASUS_ROG_ALLY_NO_POWERSAVE),
+	},
+	{ },
+};
+
+bool asus_ally_has_quirk(unsigned long quirk);
+
 #endif /* !_ASUS_WMI_H_ */
diff -rupN linux-6.10.7.orig/include/linux/platform_data/x86/asus-wmi.h linux-6.10.7/include/linux/platform_data/x86/asus-wmi.h
--- linux-6.10.7.orig/include/linux/platform_data/x86/asus-wmi.h	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/include/linux/platform_data/x86/asus-wmi.h	2024-09-03 15:03:36.720564459 +0000
@@ -4,6 +4,7 @@
 
 #include <linux/errno.h>
 #include <linux/types.h>
+#include <linux/dmi.h>
 
 /* WMI Methods */
 #define ASUS_WMI_METHODID_SPEC	        0x43455053 /* BIOS SPECification */
@@ -160,4 +161,14 @@ static inline int asus_wmi_evaluate_meth
 }
 #endif
 
+/* To be used by both hid-asus and asus-wmi to determine which controls kbd_brightness */
+static const struct dmi_system_id asus_use_hid_led_dmi_ids[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+	},
+	{ },
+};
+
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
diff -rupN linux-6.10.7.orig/drivers/hid/hid-asus.c linux-6.10.7/drivers/hid/hid-asus.c
--- linux-6.10.7.orig/drivers/hid/hid-asus.c	2024-08-29 15:36:13.000000000 +0000
+++ linux-6.10.7/drivers/hid/hid-asus.c	2024-09-03 05:45:58.091476188 +0000
@@ -52,6 +52,9 @@ MODULE_DESCRIPTION("Asus HID Keyboard an
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
+#define ALLY_CFG_INTF_IN_ADDRESS 0x83
+#define ALLY_CFG_INTF_OUT_ADDRESS 0x04
+
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
 #define MAX_TOUCH_MAJOR 8
@@ -84,6 +87,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard an
 #define QUIRK_MEDION_E1239T		BIT(10)
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
+#define QUIRK_ROG_ALLY_XPAD		BIT(13)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -492,12 +496,19 @@ static void asus_kbd_backlight_work(stru
  */
 static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
 {
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
 	u32 value;
 	int ret;
 
 	if (!IS_ENABLED(CONFIG_ASUS_WMI))
 		return false;
 
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
+			dmi_check_system(asus_use_hid_led_dmi_ids)) {
+		hid_info(hdev, "using HID for asus::kbd_backlight\n");
+		return false;
+	}
+
 	ret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,
 				       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);
 	hid_dbg(hdev, "WMI backlight check: rc %d value %x", ret, value);
@@ -996,6 +1007,16 @@ static int asus_probe(struct hid_device
 
 	drvdata->quirks = id->driver_data;
 
+	/* Ignore these endpoints as they will be used by other drivers */
+	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+		struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+		struct usb_host_endpoint *ep = intf->cur_altsetting->endpoint;
+
+		if (ep->desc.bEndpointAddress == ALLY_CFG_INTF_IN_ADDRESS ||
+			ep->desc.bEndpointAddress == ALLY_CFG_INTF_OUT_ADDRESS)
+			return -ENODEV;
+	}
+
 	/*
 	 * T90CHI's keyboard dock returns same ID values as T100CHI's dock.
 	 * Thus, identify T90CHI dock with product name string.
@@ -1247,7 +1268,7 @@ static const struct hid_device_id asus_d
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
