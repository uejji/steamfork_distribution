diff -rupN linux-6.10.6.orig/drivers/platform/x86/asus-wmi.c linux-6.10.6/drivers/platform/x86/asus-wmi.c
--- linux-6.10.6.orig/drivers/platform/x86/asus-wmi.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/platform/x86/asus-wmi.c	2024-08-27 20:52:04.186398101 +0000
@@ -11,8 +11,11 @@
  * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
  */
 
+#include "linux/usb/ch9.h"
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include "linux/printk.h"
+
 #include <linux/acpi.h>
 #include <linux/backlight.h>
 #include <linux/debugfs.h>
@@ -137,9 +140,7 @@ module_param(fnlock_default, bool, 0444)
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
-/* Controls the power state of the USB0 hub on ROG Ally which input is on */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/* 300ms so far seems to produce a reliable result on AC and battery */
 #define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
@@ -254,9 +255,6 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
-	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
-	bool ally_mcu_usb_switch;
-
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -315,6 +313,9 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
+static bool ally_mcu_usb_switch;
+static int ally_suspended_power_state;
+
 /* WMI ************************************************************************/
 
 static int asus_wmi_evaluate_method3(u32 method_id,
@@ -1685,7 +1686,8 @@ static int asus_wmi_led_init(struct asus
 			goto error;
 	}
 
-	if (!kbd_led_read(asus, &led_val, NULL)) {
+	if (!kbd_led_read(asus, &led_val, NULL) && !dmi_match(DMI_BOARD_NAME, "RC71L")) {
+		pr_info("using asus-wmi for asus::kbd_backlight\n");
 		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
 		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
@@ -4637,6 +4639,7 @@ static int asus_wmi_add(struct platform_
 	if (err)
 		goto fail_platform;
 
+	ally_mcu_usb_switch = dmi_check_system(asus_ally_mcu_quirk);
 	/* ensure defaults for tunables */
 	asus->ppt_pl2_sppt = 5;
 	asus->ppt_pl1_spl = 5;
@@ -4649,8 +4652,6 @@ static int asus_wmi_add(struct platform_
 	asus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
-	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-						&& dmi_match(DMI_BOARD_NAME, "RC71L");
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -4843,34 +4844,6 @@ static int asus_hotk_resume(struct devic
 	return 0;
 }
 
-static int asus_hotk_resume_early(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
-			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-static int asus_hotk_prepare(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to ensure USB0 is disabled before sleep continues */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
-			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -4911,11 +4884,76 @@ static int asus_hotk_restore(struct devi
 	return 0;
 }
 
+static void asus_ally_s2idle_restore(void)
+{
+	int powersave = 0;
+	int power_state;
+
+	if (ally_mcu_usb_switch) {
+		/* Call here so it is as early as possible */
+		platform_suspend_screen_on();
+
+		power_state = power_supply_is_system_supplied();
+		asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+		/* These are the only states we need to do this for */
+		if (powersave && (!power_state || ally_suspended_power_state != power_state))
+			if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
+				pr_err("ROG Ally MCU failed to connect USB dev\n");
+	}
+}
+
+static void asus_ally_s2idle_check(void)
+{
+	int powersave = 0;
+	int power_state;
+
+	if (ally_mcu_usb_switch) {
+		power_state = power_supply_is_system_supplied();
+		asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+
+		/* Wake the device fully if AC plugged in. Prevents many issues */
+		if (power_state > 0 && ally_suspended_power_state != power_state) {
+			pm_system_wakeup();
+			return;
+		}
+
+		/*
+		 * Required to ensure device is in good state on proper resume. The device
+		 * does a partial wake on AC unplug and this can leave an Ally X in bad state.
+		 */
+		if (ally_suspended_power_state != power_state) {
+			acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7);
+			msleep(500);
+		}
+	}
+}
+
+static int asus_hotk_prepare(struct device *device)
+{
+	int powersave = 0;
+	int power_state;
+
+	if (ally_mcu_usb_switch) {
+		platform_suspend_screen_off();
+
+		ally_suspended_power_state = power_state = power_supply_is_system_supplied();
+		asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+		/* Certain operations in firmware appear to be slow when powersave is on */
+		if (powersave)
+			msleep(2000);
+	}
+	return 0;
+}
+
+static struct acpi_s2idle_dev_ops asus_ally_s2idle_dev_ops = {
+	.restore = asus_ally_s2idle_restore,
+	.check = asus_ally_s2idle_check,
+};
+
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.resume_early = asus_hotk_resume_early,
 	.prepare = asus_hotk_prepare,
 };
 
@@ -4925,7 +4963,7 @@ static int asus_wmi_probe(struct platfor
 {
 	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
 	struct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);
-	int ret;
+	int ret, err;
 
 	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
 		pr_warn("ASUS Management GUID not found\n");
@@ -4943,6 +4981,11 @@ static int asus_wmi_probe(struct platfor
 			return ret;
 	}
 
+	err = acpi_register_lps0_dev(&asus_ally_s2idle_dev_ops);
+	if (err)
+		pr_warn("failed to register LPS0 sleep handler in asus-wmi\n");
+
+
 	return asus_wmi_add(pdev);
 }
 
@@ -4975,6 +5018,7 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driv
 
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
+	acpi_unregister_lps0_dev(&asus_ally_s2idle_dev_ops);
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
 	used = false;
diff -rupN linux-6.10.6.orig/include/linux/platform_data/x86/asus-wmi.h linux-6.10.6/include/linux/platform_data/x86/asus-wmi.h
--- linux-6.10.6.orig/include/linux/platform_data/x86/asus-wmi.h	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/include/linux/platform_data/x86/asus-wmi.h	2024-08-25 05:25:25.294154561 +0000
@@ -2,6 +2,7 @@
 #ifndef __PLATFORM_DATA_X86_ASUS_WMI_H
 #define __PLATFORM_DATA_X86_ASUS_WMI_H
 
+#include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 
@@ -160,4 +161,19 @@ static inline int asus_wmi_evaluate_meth
 }
 #endif
 
+/* To be used by both hid-asus and asus-wmi to determine which controls kbd_brightness */
+static const struct dmi_system_id asus_ally_mcu_quirk[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
+		},
+	},
+	{ },
+};
+
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
diff -rupN linux-6.10.6.orig/drivers/acpi/ec.c linux-6.10.6/drivers/acpi/ec.c
--- linux-6.10.6.orig/drivers/acpi/ec.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/acpi/ec.c	2024-08-27 21:20:14.299168744 +0000
@@ -2254,6 +2254,18 @@ static const struct dmi_system_id acpi_e
 			DMI_MATCH(DMI_PRODUCT_FAMILY, "103C_5336AN HP ZHAN 66 Pro"),
 		},
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUS"),
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUS"),
+			DMI_MATCH(DMI_BOARD_NAME, "RC72LA"),
+		},
+	},
 	{ },
 };
 
diff -rupN linux-6.10.6.orig/drivers/hid/hid-asus.c linux-6.10.6/drivers/hid/hid-asus.c
--- linux-6.10.6.orig/drivers/hid/hid-asus.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/hid/hid-asus.c	2024-08-24 04:13:17.225649121 +0000
@@ -52,6 +52,10 @@ MODULE_DESCRIPTION("Asus HID Keyboard an
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
+#define ALLY_CFG_INTF_IN_ADDRESS 0x83
+#define ALLY_CFG_INTF_OUT_ADDRESS 0x04
+#define ALLY_X_INTERFACE_ADDRESS 0x87
+
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
 #define MAX_TOUCH_MAJOR 8
@@ -84,6 +88,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard an
 #define QUIRK_MEDION_E1239T		BIT(10)
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
+#define QUIRK_ROG_ALLY_XPAD		BIT(13)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -492,12 +497,19 @@ static void asus_kbd_backlight_work(stru
  */
 static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
 {
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
 	u32 value;
 	int ret;
 
 	if (!IS_ENABLED(CONFIG_ASUS_WMI))
 		return false;
 
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
+			dmi_match(DMI_BOARD_NAME, "RC71L")) {
+		hid_info(hdev, "using HID for asus::kbd_backlight\n");
+		return false;
+	}
+
 	ret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,
 				       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);
 	hid_dbg(hdev, "WMI backlight check: rc %d value %x", ret, value);
@@ -996,6 +1008,17 @@ static int asus_probe(struct hid_device
 
 	drvdata->quirks = id->driver_data;
 
+	/* Ignore these endpoints as they will be used by other drivers */
+	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+		struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+		struct usb_host_endpoint *ep = intf->cur_altsetting->endpoint;
+
+		if (ep->desc.bEndpointAddress == ALLY_X_INTERFACE_ADDRESS ||
+			ep->desc.bEndpointAddress == ALLY_CFG_INTF_IN_ADDRESS ||
+			ep->desc.bEndpointAddress == ALLY_CFG_INTF_OUT_ADDRESS)
+			return -ENODEV;
+	}
+
 	/*
 	 * T90CHI's keyboard dock returns same ID values as T100CHI's dock.
 	 * Thus, identify T90CHI dock with product name string.
@@ -1247,7 +1270,10 @@ static const struct hid_device_id asus_d
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
+	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
diff -rupN linux-6.10.6.orig/drivers/hid/hid-ids.h linux-6.10.6/drivers/hid/hid-ids.h
--- linux-6.10.6.orig/drivers/hid/hid-ids.h	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/hid/hid-ids.h	2024-08-25 03:25:38.369296369 +0000
@@ -210,6 +210,7 @@
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD3	0x1a30
 #define USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR		0x18c6
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY		0x1abe
+#define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X		0x1b4c
 #define USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD	0x196b
 #define USB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD	0x1869
 
diff -rupN linux-6.10.6.orig/sound/pci/hda/patch_realtek.c linux-6.10.6/sound/pci/hda/patch_realtek.c
--- linux-6.10.6.orig/sound/pci/hda/patch_realtek.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/sound/pci/hda/patch_realtek.c	2024-08-25 01:47:10.202095677 +0000
@@ -7409,6 +7409,7 @@ enum {
 	ALC285_FIXUP_THINKPAD_X1_GEN7,
 	ALC285_FIXUP_THINKPAD_HEADSET_JACK,
 	ALC294_FIXUP_ASUS_ALLY,
+	ALC294_FIXUP_ASUS_ALLY_X,
 	ALC294_FIXUP_ASUS_ALLY_PINS,
 	ALC294_FIXUP_ASUS_ALLY_VERBS,
 	ALC294_FIXUP_ASUS_ALLY_SPEAKER,
@@ -8875,6 +8876,12 @@ static const struct hda_fixup alc269_fix
 		.chained = true,
 		.chain_id = ALC294_FIXUP_ASUS_ALLY_PINS
 	},
+	[ALC294_FIXUP_ASUS_ALLY_X] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = tas2781_fixup_i2c,
+		.chained = true,
+		.chain_id = ALC294_FIXUP_ASUS_ALLY_PINS
+	},
 	[ALC294_FIXUP_ASUS_ALLY_PINS] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -10307,6 +10314,7 @@ static const struct snd_pci_quirk alc269
 	SND_PCI_QUIRK(0x1043, 0x1740, "ASUS UX430UA", ALC295_FIXUP_ASUS_DACS),
 	SND_PCI_QUIRK(0x1043, 0x17d1, "ASUS UX431FL", ALC294_FIXUP_ASUS_DUAL_SPK),
 	SND_PCI_QUIRK(0x1043, 0x17f3, "ROG Ally NR2301L/X", ALC294_FIXUP_ASUS_ALLY),
+	SND_PCI_QUIRK(0x1043, 0x1eb3, "ROG Ally X RC72LA", ALC294_FIXUP_ASUS_ALLY_X),
 	SND_PCI_QUIRK(0x1043, 0x1863, "ASUS UX6404VI/VV", ALC245_FIXUP_CS35L41_SPI_2),
 	SND_PCI_QUIRK(0x1043, 0x1881, "ASUS Zephyrus S/M", ALC294_FIXUP_ASUS_GX502_PINS),
 	SND_PCI_QUIRK(0x1043, 0x18b1, "Asus MJ401TA", ALC256_FIXUP_ASUS_HEADSET_MIC),
diff -rupN linux-6.10.6.orig/drivers/platform/x86/amd/pmf/pmf-quirks.c linux-6.10.6/drivers/platform/x86/amd/pmf/pmf-quirks.c
--- linux-6.10.6.orig/drivers/platform/x86/amd/pmf/pmf-quirks.c	2024-08-19 04:05:40.000000000 +0000
+++ linux-6.10.6/drivers/platform/x86/amd/pmf/pmf-quirks.c	2024-08-24 11:58:42.128829894 +0000
@@ -29,6 +29,14 @@ static const struct dmi_system_id fwbug_
 		},
 		.driver_data = &quirk_no_sps_bug,
 	},
+	{
+		.ident = "ROG Ally X",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "RC72LA"),
+		},
+		.driver_data = &quirk_no_sps_bug,
+	},
 	{}
 };
 
